" ================================
"  Language setting
" ================================
if !has("gui_running") && v:progname == "vim"
  if $LANG =~ "UTF-8"
    let lang = "UTF-8"
  elseif $LANG == "C.GBK"
    let lang = "cp936"
  endif

  if exists('lang')
    exec "set encoding=" . lang
    exec "set fileencoding=" . lang
    exec "language messages " . $LANG
    exec "set termencoding=" . lang
    unlet lang
  endif
endif

set fileencodings=utf-8,ucs-bom,cp936


exec 'set runtimepath+=' . expand('<sfile>:p:h')
if v:progname =~? 'gVIM'
  set guifont=Consolas:h14
  set guioptions-=m  "remove menu bar
  set guioptions-=T  "remove toolbar

  if fnamemodify(&shell,':t') !=? 'bash'
    exec 'source ' . expand('<sfile>:p:h') . '/bash_config.vim'
  endif
endif

set autoindent cindent nobackup hlsearch nocompatible noerrorbells

" search options
set noignorecase incsearch

set showmode ruler
set shortmess=a
set cmdheight=2

syntax on
filetype plugin indent on

" Tabstop Setting
"
set tabstop=4 softtabstop=4 shiftwidth=4

"======================================================================"
"  Add a cscope database if exists in current or ancestral directories "
"======================================================================"
if executable("cscope") && has("cscope")
"    set csprg=/usr/bin/cscope
"    set csto=1
"    set cst
"    set csverb
"    set cspc=3
    let cs_file=findfile("cscope.out", ".;")
    "echo cscope_file
    if !empty(cs_file) && filereadable(cs_file)
        let cs_pref=matchstr(cs_file, ".*/")
        silent! exec "cs add " . cs_file . "  " . cs_pref
        "execute "cs add " . cscope_file
    endif
endif

" status-line options
"set statusline=\ %F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
set laststatus=2
set statusline=%F\ %m%r%h\ %w\ \ Line:\ %l/%L:%c

"
" Auto commands
"
autocmd BufEnter *.c,*.h,*.cpp,*.hpp,*.cc,*.cxx,*.S,*.s set noexpandtab
autocmd BufEnter *.py set expandtab tabstop=4

if exists("tags")
    set tag=tags
endif

" Go to last file if invoked without arguments.
autocmd VimEnter * nested if
  \ argc() == 0 && bufname("%") == "" |
  \   exec "normal! `0" |
  \ endif
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if line("'\"") > 1 && line("'\"") <= line("$") |
  \   exec "normal! g`\"" |
  \ endif

autocmd BufWritePre *  if &modified && expand("%:e") != "md" | let l = line(".") | let c = col(".") | %s/\s\+$//e | call cursor(l, c) | endif

autocmd FileType xml,htm,html set mps+=<:>

" Maximize the windows if gvim is running
autocmd GUIEnter * simalt ~x


" Show tabs
if v:progname != "vimdiff"
"  autocmd BufEnter *.c,*.h,*.cpp,*.hpp,*.cc,*.cxx,*.S,*.s set list listchars=tab:>-
endif

"==================="
" Keymap setting
"==================="
inoremap <C-S> <ESC>:update<CR>:startinsert<CR>
nnoremap <C-S> :update<CR>

inoremap <C-F4>  <ESC>:xall<CR>
nnoremap <C-F4>  :xall<CR>

" Remove spaces of one tabstop
function <SID>vRemoveSpacesOfTab() range
    exec a:firstline . "," . a:lastline . 's/^\( \{' . &tabstop . '\}\|\t\)//e'
    let @/ = ''
endfunction
function <SID>vInsertSpacesOfTab() range
    if &g:expandtab
        let spaces = ''
        let i = 0
        while i < &tabstop
            let spaces .= ' '
            let i += 1
        endwhile
    else
        let spaces = '\t'
    endif
    exec a:firstline . "," . a:lastline . 's/^/'  . spaces . '/'
    let @/ = ''
endfunction

" Insert/Remove a `tab' of spaces (in visual mode)
"vnoremap <BS>  :s/^\t//<CR>:let @/=""<CR><ESC>gv
"vnoremap <TAB> :s/^/\t/<CR>:let @/=""<CR><ESC>gv
vnoremap <BS>  :call <SID>vRemoveSpacesOfTab()<CR><ESC>gv
vnoremap <TAB> :call <SID>vInsertSpacesOfTab()<CR><ESC>gv


" Mapped keys for NERDTree plugin
noremap <F3> :NERDTreeToggle<CR>
"#let NERDTreeIgnore = ['\.o$\|\.ko$']
let NERDTreeIgnore = ['\.o$', '\~$', '\.ko$', '\.mod\.c$', 'modules\.order$', 'modules\.builtin$']
"
let NERDTreeBookmarksFile = "~/.NERDTreeBookmarks"
let NERDTreeShowBookmarks = 1
let NERDTreeStatusline = -1

function <SID>SwitchTabStop(ts)
    let &tabstop     = a:ts
    let &softtabstop = a:ts
    let &shiftwidth  = a:ts
endfunction

noremap  <Leader>t4  :call <SID>SwitchTabStop(4)<CR>
noremap  <Leader>t8  :call <SID>SwitchTabStop(8)<CR>
" Comment the selected line
nnoremap <Leader>tc  :s/^\(\s*\)\([^#]\)/\1#\2/<CR>:let @/=''<CR>

let s:whites_visible = 0

function <SID>nToggleWhites(pattern)
    if @/ != a:pattern
        let s:whites_visible = 1
    else
        let s:whites_visible = ! s:whites_visible
    endif
    if s:whites_visible
        exec 'normal! /' . a:pattern . "/\<CR>"
        let @/ = a:pattern
    else
        let @/ = ''
    endif
    return @/
endfunction

noremap  <Leader>vt   :let @/=<SID>nToggleWhites('^\t\+')<CR>:set hls<CR>
noremap  <Leader>vta  :let @/=<SID>nToggleWhites('\t\+')<CR>:set hls<CR>
noremap  <Leader>vs   :let @/=<SID>nToggleWhites('^ \+')<CR>:set hls<CR>

" Find next word from the start postition and return the position
" of that word by expanding tabs to spaces.
function <SID>GetNextWordPosition(line, start)
	let col = 0
	let spaces = 0
	let i = a:start
    while 1
        let c = strpart(a:line, i, 1)
		let i += 1
        if c == "\t"
  			let col = (((col + 1) / &tabstop + 1) * &tabstop) - 1 | let spaces = 0
		elseif c == " "
			if spaces == &tabstop | let col += &tabstop | let spaces = 0 | else | let spaces += 1 | endif
		else
			break
        endif
    endwhile
	let col += spaces
	return col + a:start
endfunction

function <SID>GetColumnPositions(line)
	let x = 0
	let pos = []
	while x < len(a:line)
		let i = <SID>GetNextWordPosition(a:line, x)
		call add(pos, i)

		while x < len(a:line)
			let c = strpart(a:line, x, 1)
			if c == "\t" || c == " " | let x += 1 | else | break | endif
		endwhile
		while x < len(a:line)
			let c = strpart(a:line, x, 1)
			if c != "\t" && c != " " | let x += 1 | else | break | endif
		endwhile
	endwhile
	return pos
endfunction

function <SID>vAlignColumns() range
    let y = a:firstline
	let positions = <SID>GetColumnPositions(getline(y))
    while y <= a:lastline
		let newline = ""
		let i = 0
		let fields = split(getline(y))
		while i < len(fields)
			let x = strlen(newline) + 1
			let newline .= " "
			while x < positions[i]
				let newline .= " "
				let x += 1
			endwhile
			let newline .= fields[i]
			let i += 1
		endwhile
		echo newline
        let y += 1
    endwhile
endfunction

"""nnoremap <F9> :call <SID>GetNextWordPosition(getline("."),0)<CR>
"""nnoremap <F9> :echo <SID>GetColumnPositions(getline("."))<CR>

" Align fields of selected lines based on the first line
vnoremap <Leader>a :call <SID>vAlignColumns()<CR>

function <SID>vConvertTabsOrSpaces(toSpace) range
	let &l:et = a:toSpace
"	echo a:firstline
"	echo a:lastline
	exec a:firstline . "," . a:lastline . "retab!"
endfunction

" Convert tabs to spaces within selected range
vnoremap <Leader>et  :call <SID>vConvertTabsOrSpaces(0)<CR>
" Convert spaces to tabs within selected range
vnoremap <Leader>es  :call <SID>vConvertTabsOrSpaces(1)<CR>

" Convert tabs to spaces within the entire file
nnoremap %et  :% call <SID>vConvertTabsOrSpaces(0)<CR>
" Convert spaces to tabs within the entire file
nnoremap %es  :% call <SID>vConvertTabsOrSpaces(1)<CR>

"nnoremap <Leader>et  :call <SID>nConvertTabsOrSpaces(0)<CR>
"nnoremap <Leader>es  :call <SID>nConvertTabsOrSpaces(1)<CR>

" Use <TAB> key to switch between windows in NORMAL MODE
nnoremap <TAB> <C-W>W

"# Quick Replace
nnoremap <Leader>s   :%s/\<<C-r><C-w>\>//g<Left><Left>
nnoremap <Leader>S   :%s/\<<C-r><C-w>\>//g<Left><Left>
vnoremap <Leader>s   y:/\<<C-r>"\>//g<Left><Left>
vnoremap <Leader>S   y:/\<<C-r>"\>//g<Left><Left>

"# Display registers
nnoremap <Leader>r   :registers<CR>

"# Toggle line number
nnoremap <Leader>]   :let &number=!&number <bar> let &relativenumber=0 <CR>
nnoremap <Leader>[   :let &relativenumber=!&relativenumber <bar> let &number=0 <CR>

"# Hide search highlighting
nnoremap <Leader>\   :let @/ = ''<CR>

"# Join two lines
nnoremap K   kJ

nnoremap <Leader>p0 :set nopaste<cr>
nnoremap <Leader>p1 :set paste<cr>
nnoremap <Leader>u  viwu
nnoremap <Leader>U  viwU

set backspace=indent,eol,start

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" High light configurations
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
colorscheme evening2

"hi ContTabs ctermbg=yellow guibg=yellow
"hi LineNr guifg=purple gui=underline
"hi LineNr ctermfg=Magenta cterm=underline
"hi VertSplit ctermfg=DarkGrey ctermbg=DarkGrey guibg=fg guifg=fg                                                        |

" Apply local configurations for the project
let local_vimrc = findfile("local.vimrc", ".;")
if !empty(local_vimrc) && filereadable(local_vimrc)
    silent! exec "source " . local_vimrc
endif

